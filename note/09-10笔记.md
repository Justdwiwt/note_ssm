# mybatis

- [ ] mybatis对dao层的封装
- [ ] mybatis的缓存机制和驼峰映射
- [ ] mybatis的操作数据库的多表之间的关系

## mybatis对单值传递的操作

> `#{参数是任意的，但是不能不写}`

``` xml
    <select id="selectUser" resultType="User" parameterType="long">
        SELECT *
        FROM user
        WHERE id = #{id}
    </select>
```

* 使用`id`单条件查询和单条件删除时，#{参数任意}
* 使用`update`语句和`select`全部查询语句，要根据`user`模型的`get`方法取值

## mybatis多值传递——sql的区间查询

``` xml
<select id="findUserByAges" resultType="pojo.User">
    select * from user where age > 18 and age < 30
</select>
<!--xml文件认为这是标签<而不是小于号-->
```

> 解决方案：使用大段转移字符`<![CDATA[]]>`

``` xml
<select id="findUserByAges" resultType="pojo.User">
    select * from user where age > 18 and <![CDATA[age < 30]]>
</select>
```

## 动态的传入区间的两个值（同一类型的age值）

``` java
@Test
public void test02() {
    HashMap<String, Integer> map = new HashMap<>();
    int minAge = 18;
    map.put("minAge", minAge);
    int maxAge = 30;
    map.put("maxAge", maxAge);

    List<User> list = sqlSession.selectList("pojo.UserMapper.findUserByAges", map);
    for (User user : list)
        System.out.println(user);
}
```

``` xml
<select id="findUserByAges" resultType="pojo.User">
    select * from user where age > #{minAge} and <![CDATA[age < #{maxAge]]>
</select>
```

## 动态插入sql语句

``` sql
Insert into user (id,name,age,sex) values (null,#{name},#{age},#{sex})
```

需求：`user`模型中，如果只用`name`值，那么`sql`语句只插入`name`，`sql`变成了`insert into (id,name) values (null,#{name})`

> 解决方案：使用`<trim></trim>`标签

* 作用1：可以进行前缀`(`和后缀`)`的设置
* 作用2：可以使用`<if test></if>`标签判断每一个字段对应的数据模型中的值是否为空
* 作用3：可以自动的把值与列名后面的`,`去除掉

``` xml
<!-- 动态的插入语句 -->
<insert id="dynamicAddUser">
	insert into user 
		<trim prefix="(" suffix=")" suffixOverrides="," >
			id,
			<if test="name != null">name,</if>
			<if test="age != 0">age,</if>
			<if test="sex != null">sex</if>
		</trim>
	values 
		<trim prefix="(" suffix=")" suffixOverrides=",">
			null,
			<if test="name != null">#{name},</if>
			<if test="age != 0">#{age},</if>
			<if test="sex != null">#{sex}</if>
		</trim>
</insert>
```

## 动态修改sql语句

``` sql
Update user set name = #{name},age = #{age} , sex = #{sex} Where id = #{id}
```

需求：动态的根据`user`模型中的数据进行`sql`语句的编写

> 解决方案：使用`<set></set>`标签，代替了`sql` 语句中`set`关键字

* 作用1：可以进行动态的判断`user`模型中的值是否为空
* 作用2：可以去除字段末尾的`,`

``` xml
<!-- 动态修改 -->
<update id="dynamicUpdateUser">
	update user 
		<set>
			<if test="name != null"> name=#{name},</if>
			<if test="age != 0"> age=#{age},</if>
			<if test="sex != null"> sex=#{sex} </if>
		</set>
	where id=#{id}
</update>
```

## 动态删除sql语句

> 解决方案：`foreach`标签

* `foreach`标签：遍历所有的`id`并获取`id`的值
* `collection=""`：可以支持三种数据结构
    * `array`：`collection="array"`
    * `list`：`collection="list"`
    * `map`：`collection="集合对应的key"`
* `open="("`：前缀`(`
* `close=")"`：后缀`)`
* `item="tempId"`：临时变量接收数组中的每一个`id`的值
* `index="i"`：循环变量可以不写
* `separator=","`：使用`,` 隔开数组中的每一个值

注意：
* 使用`array`与`list`集合，只能删除单一字段类型的多个值
* 使用`map`集合，可以删除多个字段类型的多个值

``` xml
<delete id="dynamicDeleteUserByArray">
delete from user where id in 
<foreach collection="array" open="(" close=")" item="tempId" index="i" separator=","  >
#{i}
</foreach>
</delete>
 
<delete id="dynamicDeleteUserByList">
delete from user where id in 
<foreach collection="list" open="(" close=")" item="tempId"  separator=","  >
#{tempId}
</foreach>
</delete>
 
<delete id="dynamicDeleteUserByMap">
delete from user where id in 
<!-- 使用map集合，循环遍历list集合
collection="ids" ： ids 为 map中的key
 -->
<foreach collection="ids" open="(" close=")" item="tempId"  separator=","  >
#{tempId}
</foreach>
or sex=#{sex}
</delete>
```

* `foreach`不只可以用在`delete`语句中，
也可以根据需求在`select`与`update`中使用

## sql复用的问题

> 在映射文件中，使用`<sql>`标签

``` xml
<sql id="selectUser">
    select * from user
</sql>

<select id="findOne" resultType="User">
    <include refid="selectUser"/>where id = #{sdf}
</select>
```

## Mybatis对dao层的封装以及方法的调用

原来的`dao`层：`UserDao`接口和`UserDaoImpl`实现类
`Mybatis`的`dao`层：`UserMapper`接口（提供`crud`的方法）底层使用`jdk`的动态代理创建`userMapper`的代理对象
使用的`API`：`sqlSession.getMapper(UserMapper.class);`

### 实现步骤

1. 编写`UserMapper`的接口

    ``` java
    package mapper;

    import java.util.HashMap;
    import java.util.List;

    import pojo.User;

    //接口：是执行crud的方法
    //注意：方法签名  一定要和  映射文件中的sql语句的id一致
    public interface UserMapper {
        
        public User findOne(int id);
        
        /* UserMapper方法：取代了 CRUD
        * 取代了 它-->
        *  List<User> list = sqlSession.selectList
                    ("pojo.UserMapper.findUserByAges", map);
        */
        public List<User> findUserByAges(HashMap<String,Integer> map);

    }
    ```

2. 修改`UserMapper.xml`文件

    ``` xml
    <?xml version="1.0" encoding="UTF-8" ?>
    <!DOCTYPE mapper
    PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
    "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
    <!-- 用于唯一标识当前的映射文件 -->
    <mapper namespace="mapper.UserMapper">
        
        <!-- sql复用问题：作为公共的查询语句 -->
        <sql id="selectUser">
            select * from user 
        </sql>
        
        <!-- 单值传递问题 -->
        <select id="findOne" resultType="User">
            <!-- select * from user where id=#{idqweqwe} -->
            <include refid="selectUser"/> where id=#{sdf}
        </select>
        
        <!-- 多值传递问题  区间查询 -->
        <select id="findUserByAges" resultType="User">
            select * from user where age > #{minAge} and 
            <!-- xml文件会根据   转义字符 进行  转义<>标签的形式   -->
            <![CDATA[age < #{maxAge}]]>
        </select>
        
        <!-- 动态的插入语句 -->
        <insert id="dynamicAddUser">
            insert into user 
                <trim prefix="(" suffix=")" suffixOverrides="," >
                    id,
                    <if test="name != null">name,</if>
                    <if test="age != 0">age,</if>
                    <if test="sex != null">sex</if>
                </trim>
            values 
                <trim prefix="(" suffix=")" suffixOverrides=",">
                    null,
                    <if test="name != null">#{name},</if>
                    <if test="age != 0">#{age},</if>
                    <if test="sex != null">#{sex}</if>
                </trim>
        </insert>
        
        <!-- 动态修改 -->
        <update id="dynamicUpdateUser">
            update user 
                <set>
                    <if test="name != null"> name=#{name},</if>
                    <if test="age != 0"> age=#{age},</if>
                    <if test="sex != null"> sex=#{sex} </if>
                </set>
            where id=#{id}
        </update>
        <!-- foreach标签  ： 遍历  所有的id 并获取id的值
                    collection="" : 可以支持三种数据结构：array list map 
                                特殊用法：array数组  collection="array"
                                    list集合    collection="list" 
                                    map映射       collection="？？？"
                    open="("  : 前缀 ( 
                    close=")" : 后缀 )
                    item="tempId" : 临时变量 接收 数组中的每一个id的值
                    index="i" : 循环变量  可以不写
                    separator="," 使用, 隔开 数组中的每一个值
                -->
        <delete id="dynamicDeleteUserByArray">
            delete from user where id in 
                <foreach collection="array" open="(" close=")" item="tempId" index="i" separator=","  >
                    #{i}
                </foreach>
        </delete>
        
        <delete id="dynamicDeleteUserByList">
            delete from user where id in 
                <foreach collection="list" open="(" close=")" item="tempId"  separator=","  >
                    #{tempId}
                </foreach>
        </delete>
        
        <delete id="dynamicDeleteUserByMap">
            delete from user where id in 
                <!-- 使用map集合，循环遍历list集合
                    collection="ids" ： ids 为 map中的key
                -->
                <foreach collection="ids" open="(" close=")" item="tempId"  separator=","  >
                    #{tempId}
                </foreach>
            or sex=#{sex}
        </delete>
        
    </mapper>
    ```

3. 单元测试

    ``` java
        //单值传递:使用UserMapper接口
        @Test
        public void test01() {
            int id = 9;
    //		User user = sqlSession.selectOne
    //				("pojo.UserMapper.findOne", id);
            //获取了一个 userMapper的对象
            //底层使用了jdk的动态代理：逆向的生成了一个代理对象
            UserMapper userMapper = sqlSession.
                    getMapper(UserMapper.class);
            System.out.println(userMapper.getClass());
            
            //使用对象操作CRUD
            User user = userMapper.findOne(9);
            System.out.println(user);
        }
    ```

底层的结果输出：`userMapper`为`jdk`动态代理创建的代理对象

![](img/userMapper.png)

## 数据表之间的关联关系

* 1:1
* 1:n
* n:n

